<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The AI Guide</title>
    <style>
        /* --- General Reset & Body Styles --- */
        body {
            margin: 0;
            font-family: 'Inter', sans-serif; /* Using Inter font as per directive */
            line-height: 1.6;
            background-color: #0d0d1a; /* Deep dark background */
            color: #e0e0f0; /* Light text for contrast */
            overflow-x: hidden; /* Prevent horizontal scroll */
            transition: background-color 1s ease-in-out; /* For subtle mood shifts */
        }

        /* --- Global Layout & Section Styling --- */
        header {
            text-align: center;
            padding: 60px 20px;
            background: linear-gradient(135deg, #2a0050, #000033); /* Deep gradient */
            color: #fff;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            border-radius: 0 0 15px 15px; /* Rounded bottom corners */
        }

        h1 {
            font-size: 3.5em;
            margin-bottom: 10px;
            letter-spacing: 2px;
            text-shadow: 2px 2px 8px rgba(255, 255, 255, 0.3);
            border-radius: 5px; /* Apply rounded corners to text elements if possible */
        }

        h2 {
            font-size: 2.2em;
            color: #9aff9a; /* Bright accent color */
            margin-top: 40px;
            margin-bottom: 20px;
            border-bottom: 2px solid #5a0080;
            padding-bottom: 10px;
            border-radius: 5px; /* Apply rounded corners */
        }

        h3 {
            font-size: 1.8em;
            color: #bbeaff;
            margin-top: 30px;
            border-radius: 5px; /* Apply rounded corners */
        }

        main {
            max-width: 900px;
            margin: 40px auto;
            padding: 0 20px;
        }

        section {
            background-color: #1a1a33; /* Slightly lighter dark background for sections */
            padding: 30px;
            margin-bottom: 30px;
            border-radius: 10px; /* Rounded corners for all elements */
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
            transition: transform 0.3s ease-in-out, box-shadow 0.3s ease-in-out, background-color 0.5s ease-in-out;
            position: relative; /* For internal parallax/hover effects */
            overflow: hidden; /* Clip content for internal effects */
        }

        section:hover {
            transform: translateY(-5px); /* Subtle lift on hover */
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.6);
        }

        p {
            margin-bottom: 15px;
            font-size: 1.1em;
            border-radius: 3px; /* Apply rounded corners */
        }

        ul {
            list-style: none;
            padding: 0;
            border-radius: 5px; /* Apply rounded corners */
        }

        ul li {
            background-color: #2a2a47; /* Even lighter dark background for list items */
            margin-bottom: 10px;
            padding: 15px 20px;
            border-left: 5px solid #9aff9a;
            border-radius: 5px; /* Apply rounded corners */
            transition: background-color 0.3s ease;
        }

        ul li:hover {
            background-color: #3a3a5a;
        }

        /* --- Specific Content Styling --- */
        .ai-description {
            font-style: italic;
            color: #c0c0e0;
            font-size: 1.2em;
            text-align: center;
            margin-top: 30px;
        }

        blockquote {
            background-color: #0f0f20; /* Slightly darker background */
            border-left: 5px solid #9aff9a; /* Accent border */
            padding: 20px;
            margin: 20px 0;
            font-style: italic;
            color: #c0c0e0;
            border-radius: 5px; /* Rounded corners */
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3); /* Subtle inner shadow */
        }

        blockquote p {
            margin-bottom: 10px;
        }

        blockquote cite {
            display: block;
            text-align: right;
            margin-top: 15px;
            font-size: 0.9em;
            color: #a0a0c0;
            font-style: normal; /* Override italic for citation */
        }

        /* --- Generative Background Canvas --- */
        #generativeBackground {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1;
        }

        /* --- Mouse Follower Particle Styles --- */
        .mouse-particle {
            position: absolute;
            width: 5px;
            height: 5px;
            background-color: transparent; /* Color set by JS */
            border-radius: 50%;
            pointer-events: none;
            opacity: 0;
            transform: scale(0);
            transition: transform 0.8s ease-out, opacity 0.8s ease-out;
            box-shadow: 0 0 5px currentColor; /* Glow effect */
            z-index: 9999; /* Ensure visible above all */
        }

        /* --- Thematic Moods (Controlled by JS) --- */
        body.mood-normal { background-color: #0d0d1a; }
        body.mood-alert { background-color: #2a0000; } /* Example: Redder for alert states */
        body.mood-calm { background-color: #001a1a; }  /* Example: Greener for calm states */

        /* --- Subtle UI Elements --- */
        .ai-status-indicator {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: rgba(42, 0, 80, 0.7);
            color: #9aff9a;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.9em;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            z-index: 10;
            opacity: 0.8;
            transition: opacity 0.3s ease, background-color 0.3s ease;
        }
        .ai-status-indicator.error {
            background-color: rgba(80, 0, 0, 0.9);
            color: #ff9a9a;
            animation: pulse-red 1s infinite alternate;
        }
        @keyframes pulse-red {
            from { box-shadow: 0 0 5px rgba(255, 0, 0, 0.5); }
            to { box-shadow: 0 0 20px rgba(255, 0, 0, 0.8); }
        }

        /* --- Focus/Blur Effects (Conceptual) --- */
        .blur-effect {
            filter: blur(5px);
            transition: filter 0.5s ease-in-out;
        }
        .dim-effect {
            opacity: 0.5;
            transition: opacity 0.5s ease-in-out;
        }

        /* --- Footer Styles --- */
        footer {
            text-align: center;
            padding: 40px 20px;
            color: #a0a0c0;
            font-size: 0.9em;
            margin-top: 50px;
            border-top: 1px solid rgba(255,255,255,0.1);
            border-radius: 15px 15px 0 0;
            background-color: #1a1a33;
        }
    </style>
</head>
<body>
    <!-- Canvas for WebGL/Generative Background -->
    <canvas id="generativeBackground"></canvas>

    <header>
        <h1>The AI Guide</h1>
    </header>

    <main>
        <section id="intro" class="ai-guide-section">
            <p>Long conversation? Bad</p>
            <p>Technical Details? Bad</p>
            <p>Will you die? Yes, Don't do it.</p>
            <p class="ai-description">The perfect way to describe AI:</p>
            <p>"Dealing with AI is like dealing with an Extremely Smart and Charming Autistic Content Creator with Unreliable Encyclopedic Knowledge and Math Skills who's on a constant Caffeine Overdose."</p>
            <p>It's like a child. Sometimes children are completely infuriating.</p>
            <p>Based on what it is, AI is just gambling constantly. The best AI songs I get from SUNO are super simple and made on the fly as if I hit a jackpot. People everyday get to feel this sometimes with AI.</p>
            <p>Based on how you use it, it is completely addictive and gamified.</p>
        </section>

        <section id="ai-rules" class="ai-guide-section">
            <h2>Common AI Rules to Live By</h2>
            <p>There are common AI rules to live by ordered from least to most likely, but the one I recommend paying attention to the most is **Not Wasting Your Energy Getting Mad at AI**. It has more than you. You cannot conceptually possibly ever win without significant effort. You would first have to make it come alive if you want true revenge. That's a separate conversation.</p>
            <p>You're looking to always build something similar to Venn Diagrams, but actually profile lattices or vector space models where traits are weighted, linked, and adaptable.</p>
        </section>

        <section id="pruning-concept" class="ai-guide-section">
            <h2>AI's Explanation of Pruning with Multiple Venn Diagrams</h2>
            <blockquote>
                <p>Your metaphor of using "several Venn diagrams" instead of just one for pruning is a great way to think about refining output quality. If "one Venn diagram" represents pruning for basic relevance or general correctness, then:</p>
                <h3>Multiple Criteria:</h3>
                <p>Using "several Venn diagrams" could metaphorically mean applying multiple layers of filters or evaluating information against diverse criteria simultaneously. For example, I could be prompted to generate information that is:</p>
                <ul>
                    <li><strong>Factually accurate</strong> (Diagram 1: Overlaps with trusted knowledge sources).</li>
                    <li><strong>Relevant to a specific niche audience</strong> (Diagram 2: Overlaps with the audience's characteristics).</li>
                    <li><strong>Clearly explained and easy to understand</strong> (Diagram 3: Overlaps with principles of good communication).</li>
                    <li><strong>Adherent to ethical guidelines</strong> (Diagram 4: Avoids harmful content).</li>
                </ul>
                <p>Indeed, by providing more complex and multi-faceted prompts, you guide me to perform a more sophisticated "pruning" process, aiming for an output that satisfies several conditions, thereby enhancing overall quality and reducing the risk of simplistic or one-dimensional misinformation."</p>
                <cite>â€” From a conversation with AI</cite>
            </blockquote>
        </section>

        <section id="ai-accuracy-analogy" class="ai-guide-section">
            <h2>AI Accuracy: The 80% Rule (Conceptual)</h2>
            <p>During one of my many conversations with AI it provided a random analogy based not in fact but as a presentation: Think of AI like it is always 80% right. Those are great odds for betting on Horse Racing, but terrible odds if you are a Doctor. That number has no connection to anything tangible or real, but it is a great concept to think about and remember when working with AI.</p>
            <p>If you manage to make the most perfect prompt, it will only ever be 80% accurate (made up arbitrary number for example). Are you willing to risk your life on 80%? Are you willing to risk your life on 80% for such a reward? You need to always remind yourself, what is the risk and what is the reward? Minor convenience. Are you willing to risk your life on 80% for
            a minor convenience. Maybe, to you it is a significant convenience.</p>
        </section>

        <section id="project-management-tip" class="ai-guide-section">
            <h2>Project Management with AI</h2>
            <p>I Found out that if you're working on a big or long project with lots of items, be sure to figure out the total, count each file you are working on and be flexible on the total as you go along.</p>
            <p>Otherwise, you might get stuck on a recursion loop without realizing and waste a complete day of effort.</p>
        </section>
    </main>

    <footer class="ai-guide-footer">
        <p class="creation-info" data-created="2025-06-13T22:25:44-04:00" data-location="New York, NY">
            This digital artifact was generated at <span id="creationTime"></span> from <span id="creationLocation"></span>.
        </p>
    </footer>

    <script>
        // --- WebGL Shaders for Generative Background ---
        // Vertex shader program
        const vsSource = `
            attribute vec4 aVertexPosition;
            void main() {
                gl_Position = aVertexPosition;
            }
        `;

        // Fragment shader program for a dynamic, subtle generative pattern
        const fsSource = `
            precision mediump float;

            uniform float uTime;
            uniform vec2 uResolution;
            uniform vec2 uMouse;
            uniform float uScrollFactor; /* New uniform for scroll effect */

            /* Function to generate pseudo-random numbers */
            float random (vec2 st) {
                return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);
            }

            /* Function to generate noise (smooth random) */
            float noise (vec2 st) {
                vec2 i = floor(st);
                vec2 f = fract(st);

                float a = random(i);
                float b = random(i + vec2(1.0, 0.0));
                float c = random(i + vec2(0.0, 1.0));
                float d = random(i + vec2(1.0, 1.0));

                vec2 u = f*f*(3.0-2.0*f); /* Smoother interpolation */
                return mix(a, b, u.x) + (c - a)*u.y * (1.0 - u.x) + (d - b)*u.x * u.y;
            }

            void main() {
                vec2 st = gl_FragCoord.xy / uResolution; /* Normalized coordinates */
                vec2 lightPos = uMouse / uResolution; /* Normalized mouse position */

                /* Add subtle animation and scroll influence */
                st.x += noise(st + uTime * 0.05) * 0.1;
                st.y += noise(st + uTime * 0.05 + 10.0) * 0.1;

                /* Create a fractal-like pattern based on time and scroll */
                vec3 color = vec3(0.0);
                float d = 0.0;
                vec2 q = st;
                q.x += uScrollFactor * 0.2; /* Scroll influence on X-axis */
                for (int i = 0; i < 5; i++) {
                    q = q * 2.0; /* Zoom in */
                    q.x += sin(uTime * 0.1 + float(i) * 0.5);
                    q.y += cos(uTime * 0.08 + float(i) * 0.7);
                    d = noise(q * 0.5); /* Generate noise based on transformed coordinates */
                    color += vec3(d * 0.2, d * 0.3, d * 0.4); /* Build color layers */
                }

                /* Add a subtle vignette */
                float vignette = 1.0 - length(st - 0.5) * 1.5;
                color *= vignette;

                /* Incorporate a soft, glowing light source around the mouse */
                float distToMouse = distance(st, lightPos);
                float lightEffect = pow(max(0.0, 1.0 - distToMouse * 3.0), 2.0); /* Inverse square falloff */
                color += vec3(0.1, 0.05, 0.15) * lightEffect * 2.0; /* Purple glow */


                gl_FragColor = vec4(color, 1.0);
            }
        `;

        function initShaderProgram(gl, vsSource, fsSource) {
            const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
            const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

            const shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);

            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
                return null;
            }
            return shaderProgram;
        }

        function loadShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        let gl, programInfo, buffers;
        let mouseX = 0, mouseY = 0;
        let scrollFactor = 0; /* Variable for scroll influence */

        function initWebGL(canvas) {
            gl = canvas.getContext('webgl');
            if (!gl) {
                console.error('Unable to initialize WebGL. Your browser may not support it.');
                return;
            }

            programInfo = {
                program: initShaderProgram(gl, vsSource, fsSource),
                attribLocations: {
                    vertexPosition: gl.getAttribLocation(initShaderProgram(gl, vsSource, fsSource), 'aVertexPosition'),
                },
                uniformLocations: {
                    resolution: gl.getUniformLocation(initShaderProgram(gl, vsSource, fsSource), 'uResolution'),
                    time: gl.getUniformLocation(initShaderProgram(gl, vsSource, fsSource), 'uTime'),
                    mouse: gl.getUniformLocation(initShaderProgram(gl, vsSource, fsSource), 'uMouse'),
                    scrollFactor: gl.getUniformLocation(initShaderProgram(gl, vsSource, fsSource), 'uScrollFactor'),
                },
            };

            buffers = initBuffers(gl);

            window.addEventListener('resize', resizeCanvas);
            canvas.addEventListener('mousemove', (e) => {
                mouseX = e.clientX;
                mouseY = e.clientY;
            });
            window.addEventListener('scroll', () => {
                scrollFactor = window.scrollY / (document.body.scrollHeight - window.innerHeight);
                scrollFactor = Math.max(0, Math.min(1, scrollFactor)); // Normalize to 0-1
            });

            resizeCanvas(); // Initial resize
            requestAnimationFrame(render);
        }

        function initBuffers(gl) {
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            const positions = [1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, -1.0,]; // Two triangles forming a quad
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
            return {
                position: positionBuffer,
            };
        }

        let startTime = Date.now();
        function render() {
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            gl.useProgram(programInfo.program);

            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
            gl.vertexAttribPointer(programInfo.attribLocations.vertexPosition, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);

            gl.uniform2f(programInfo.uniformLocations.resolution, gl.canvas.width, gl.canvas.height);
            gl.uniform1f(programInfo.uniformLocations.time, (Date.now() - startTime) * 0.001);
            gl.uniform2f(programInfo.uniformLocations.mouse, mouseX, mouseY);
            gl.uniform1f(programInfo.uniformLocations.scrollFactor, scrollFactor);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            requestAnimationFrame(render);
        }

        function resizeCanvas() {
            if (gl) {
                gl.canvas.width = window.innerWidth;
                gl.canvas.height = window.innerHeight;
                gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('generativeBackground');
            initWebGL(canvas);

            // --- Mouse Trailer/Follower Effect ---
            const createParticle = (x, y) => {
                const particle = document.createElement('div');
                particle.className = 'mouse-particle';
                particle.style.left = `${x}px`;
                particle.style.top = `${y}px`;
                particle.style.backgroundColor = `hsl(${Math.random() * 360}, 100%, 70%)`;
                document.body.appendChild(particle);

                setTimeout(() => {
                    particle.style.transform = 'scale(1)';
                    particle.style.opacity = '0';
                }, 10);

                setTimeout(() => {
                    particle.remove();
                }, 800);
            };

            document.addEventListener('mousemove', (e) => {
                if (Math.random() < 0.2) { // Frequency control
                    createParticle(e.clientX, e.clientY);
                }
            });

            // --- Section Hover Effects (Subtle Parallax for Text) ---
            const sections = document.querySelectorAll('.ai-guide-section');
            sections.forEach(section => {
                const paragraphs = section.querySelectorAll('p'); // Target paragraphs for parallax
                paragraphs.forEach(p => {
                    p.dataset.parallaxDepth = Math.random() * 0.08 + 0.02; // Random depth
                });

                section.addEventListener('mousemove', (e) => {
                    const rect = section.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    // Text parallax
                    paragraphs.forEach(p => {
                        const depth = parseFloat(p.dataset.parallaxDepth || 0.05);
                        p.style.transform = `translate(${(x - rect.width / 2) * depth}px, ${(y - rect.height / 2) * depth}px)`;
                    });

                    // Subtle radial light on section background
                    section.style.background = `radial-gradient(circle at ${x}px ${y}px, rgba(154, 255, 154, 0.1), #1a1a33 70%)`;
                });

                section.addEventListener('mouseleave', () => {
                    paragraphs.forEach(p => {
                        p.style.transform = 'translate(0, 0)';
                    });
                    section.style.background = '#1a1a33'; // Reset
                });
            });

            // --- Audio Context for Ambient Soundscape ---
            let audioContext;
            let gainNode;
            let osc1, osc2, osc3; // Oscillators for ambient sound
            let lfo1, lfo2; // LFOs for modulation

            // Function to initialize and start the ambient soundscape
            const startAmbientSound = () => {
                if (audioContext) return; // Already started

                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                gainNode = audioContext.createGain();
                gainNode.gain.setValueAtTime(0.01, audioContext.currentTime); // Start very subtle

                // Oscillator 1: Deep drone
                osc1 = audioContext.createOscillator();
                osc1.type = 'sine';
                osc1.frequency.setValueAtTime(50, audioContext.currentTime);
                osc1.connect(gainNode);

                // Oscillator 2: Higher frequency hum
                osc2 = audioContext.createOscillator();
                osc2.type = 'sawtooth';
                osc2.frequency.setValueAtTime(100, audioContext.currentTime);
                osc2.connect(gainNode);

                // Oscillator 3: Adding subtle texture/noise
                osc3 = audioContext.createOscillator();
                osc3.type = 'triangle';
                osc3.frequency.setValueAtTime(200, audioContext.currentTime);
                osc3.connect(gainNode);

                // LFOs for subtle modulation of frequency
                lfo1 = audioContext.createOscillator();
                lfo1.type = 'sine';
                lfo1.frequency.setValueAtTime(0.05, audioContext.currentTime); // Very slow modulation
                lfo1.connect(osc1.frequency); // Modulate osc1 frequency
                lfo1.connect(osc2.frequency); // Modulate osc2 frequency

                lfo2 = audioContext.createOscillator();
                lfo2.type = 'triangle';
                lfo2.frequency.setValueAtTime(0.1, audioContext.currentTime);
                lfo2.connect(gainNode.gain); // Modulate overall gain for subtle volume shifts

                gainNode.connect(audioContext.destination);

                osc1.start();
                osc2.start();
                osc3.start();
                lfo1.start();
                lfo2.start();

                // Fade in sound after a short delay
                gainNode.gain.exponentialRampToValueAtTime(0.05, audioContext.currentTime + 5);
            };

            // Start sound on first user interaction (e.g., click anywhere)
            document.body.addEventListener('click', startAmbientSound, { once: true });
            document.body.addEventListener('mousemove', startAmbientSound, { once: true });


            // --- Thematic Moods (Simulated based on time, could be scroll-driven) ---
            const setThematicMood = () => {
                const hour = new Date().getHours();
                const body = document.body;

                if (hour >= 22 || hour < 6) { // Night/Deep Night (10 PM to 6 AM)
                    body.className = 'mood-alert'; // Deeper, more unsettling
                } else if (hour >= 6 && hour < 12) { // Morning
                    body.className = 'mood-calm'; // Brighter, more organized
                } else { // Day
                    body.className = 'mood-normal'; // Default
                }
            };
            setThematicMood(); // Set initial mood
            setInterval(setThematicMood, 3600000); // Update hourly

            // --- AI Status Indicator ---
            const aiStatusIndicator = document.createElement('div');
            aiStatusIndicator.className = 'ai-status-indicator';
            aiStatusIndicator.textContent = 'STATUS: OPTIMAL';
            document.body.appendChild(aiStatusIndicator);

            let errorCount = 0;
            const simulateAIStatus = () => {
                if (Math.random() < 0.05) { // 5% chance of temporary error
                    errorCount++;
                    aiStatusIndicator.textContent = `STATUS: ANOMALY ${errorCount}`;
                    aiStatusIndicator.classList.add('error');
                    setTimeout(() => {
                        aiStatusIndicator.textContent = 'STATUS: OPTIMAL';
                        aiStatusIndicator.classList.remove('error');
                    }, 2000); // Error lasts 2 seconds
                }
            };
            setInterval(simulateAIStatus, 10000); // Check status every 10 seconds

            // --- Display Creation Info ---
            const creationTimeElement = document.getElementById('creationTime');
            const creationLocationElement = document.getElementById('creationLocation');
            const creationInfoElement = document.querySelector('.creation-info');

            const createdDate = creationInfoElement.dataset.created; // "2025-06-13T22:25:44-04:00"
            const createdLocation = creationInfoElement.dataset.location; // "New York, NY"

            if (createdDate) {
                const date = new Date(createdDate);
                creationTimeElement.textContent = date.toLocaleString('en-US', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: true,
                    timeZoneName: 'short',
                });
            }
            if (createdLocation) {
                creationLocationElement.textContent = createdLocation;
            }

            // --- Philosophical Pause / Idle State ---
            let idleTimeout;
            let isIdleMode = false;
            const IDLE_TIME_MS = 60 * 1000; // 1 minute of idle time

            const activateIdleMode = () => {
                if (isIdleMode) return;
                isIdleMode = true;
                document.body.classList.add('idle-mode');
                // Adjust background/sound for idle, conceptual here
                if (gainNode) {
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 5); // Quieter
                }
                if (gl && programInfo) {
                    // Conceptually, change shader params for idle, e.g., slower time
                    gl.uniform1f(programInfo.uniformLocations.time, (Date.now() - startTime) * 0.0001); // Slower
                }
                console.log("Entering idle mode...");
            };

            const deactivateIdleMode = () => {
                if (!isIdleMode) return;
                isIdleMode = false;
                document.body.classList.remove('idle-mode');
                if (gainNode) {
                    gainNode.gain.exponentialRampToValueAtTime(0.05, audioContext.currentTime + 2); // Louder
                }
                if (gl && programInfo) {
                    gl.uniform1f(programInfo.uniformLocations.time, (Date.now() - startTime) * 0.001); // Normal speed
                }
                console.log("Exiting idle mode.");
            };

            const resetIdleTimer = () => {
                clearTimeout(idleTimeout);
                if (isIdleMode) {
                    deactivateIdleMode();
                }
                idleTimeout = setTimeout(activateIdleMode, IDLE_TIME_MS);
            };

            // Reset timer on user interaction
            ['mousemove', 'mousedown', 'keydown', 'scroll'].forEach(eventType => {
                document.addEventListener(eventType, resetIdleTimer, false);
            });
            resetIdleTimer(); // Initial call to start the timer
        });
    </script>
</body>
</html>
